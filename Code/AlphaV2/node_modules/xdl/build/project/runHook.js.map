{"version":3,"sources":["../../src/project/runHook.ts"],"names":["requireFromProject","projectRoot","modulePath","fullPath","require","prepareHooks","hooks","hookType","validHooks","forEach","hook","file","fn","logger","global","error","_fn","push","undefined","length","XDLError","runHook","hookOptions","result","config","then","info","quiet"],"mappings":";;;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAMA,SAASA,kBAAT,CAA4BC,WAA5B,EAAiDC,UAAjD,EAAqE;AACnE,MAAI;AACF,UAAMC,QAAQ,GAAG,4BAAYF,WAAZ,EAAyBC,UAAzB,CAAjB,CADE,CAEF;AACA;;AACA,4BAAQC,QAAR;AACA,WAAOC,OAAO,CAACD,QAAD,CAAd;AACD,GAND,CAME,MAAM;AACN,WAAO,IAAP;AACD;AACF;;AAEM,SAASE,YAAT,CAAsBC,KAAtB,EAAkDC,QAAlD,EAAsEN,WAAtE,EAA2F;AAChG,QAAMO,UAAwB,GAAG,EAAjC;;AAEA,MAAIF,KAAJ,EAAW;AAAA;;AACT,QAAIA,KAAK,CAACC,QAAD,CAAT,EAAqB;AACnBD,MAAAA,KAAK,CAACC,QAAD,CAAL,CAAiBE,OAAjB,CAA0BC,IAAD,IAAe;AACtC,cAAM;AAAEC,UAAAA;AAAF,YAAWD,IAAjB;AACA,cAAME,EAAE,GAAGZ,kBAAkB,CAACC,WAAD,EAAcU,IAAd,CAA7B;;AACA,YAAI,OAAOC,EAAP,KAAc,UAAlB,EAA8B;AAC5BC,6BAAOC,MAAP,CAAcC,KAAd,CACG,kBAAiBR,QAAS,WAAUI,IAAK,2CAD5C;AAGD,SAJD,MAIO;AACLD,UAAAA,IAAI,CAACM,GAAL,GAAWJ,EAAX;AACAJ,UAAAA,UAAU,CAACS,IAAX,CAAgBP,IAAhB;AACD;AACF,OAXD;AAYD;;AAED,QAAIJ,KAAK,CAACC,QAAD,CAAL,KAAoBW,SAApB,IAAiCV,UAAU,CAACW,MAAX,yBAAsBb,KAAK,CAACC,QAAD,CAA3B,oDAAsB,gBAAiBY,MAAvC,CAArC,EAAoF;AAClF,YAAM,KAAIC,oBAAJ,EACJ,2BADI,EAEH,mBAAkBb,QAAS,qBAFxB,CAAN;AAID;AACF;;AAED,SAAOC,UAAP;AACD;;AAEM,eAAea,OAAf,CAAuBX,IAAvB,EAAyCY,WAAzC,EAAqF;AAC1F,MAAIC,MAAM,GAAGb,IAAI,CAACM,GAAL,CAAS;AACpBQ,IAAAA,MAAM,EAAEd,IAAI,CAACc,MADO;AAEpB,OAAGF;AAFiB,GAAT,CAAb,CAD0F,CAM1F;;;AACA,MAAIC,MAAM,IAAIA,MAAM,CAACE,IAArB,EAA2B;AACzBF,IAAAA,MAAM,GAAG,MAAMA,MAAf;AACD;;AAED,MAAIA,MAAJ,EAAY;AACVV,uBAAOC,MAAP,CAAcY,IAAd,CAAmB;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAAnB,EAAoCJ,MAApC;AACD;AACF","sourcesContent":["import { ExpoConfig, Hook, HookArguments, HookType } from '@expo/config';\nimport decache from 'decache';\nimport resolveFrom from 'resolve-from';\n\nimport { Logger as logger, XDLError } from '../internal';\n\nexport type LoadedHook = Hook & {\n  _fn: (input: HookArguments) => any;\n};\n\nfunction requireFromProject(projectRoot: string, modulePath: string) {\n  try {\n    const fullPath = resolveFrom(projectRoot, modulePath);\n    // Clear the require cache for this module so get a fresh version of it\n    // without requiring the user to restart Expo CLI\n    decache(fullPath);\n    return require(fullPath);\n  } catch {\n    return null;\n  }\n}\n\nexport function prepareHooks(hooks: ExpoConfig['hooks'], hookType: HookType, projectRoot: string) {\n  const validHooks: LoadedHook[] = [];\n\n  if (hooks) {\n    if (hooks[hookType]) {\n      hooks[hookType]!.forEach((hook: any) => {\n        const { file } = hook;\n        const fn = requireFromProject(projectRoot, file);\n        if (typeof fn !== 'function') {\n          logger.global.error(\n            `Unable to load ${hookType} hook: '${file}'. The module does not export a function.`\n          );\n        } else {\n          hook._fn = fn;\n          validHooks.push(hook);\n        }\n      });\n    }\n\n    if (hooks[hookType] !== undefined && validHooks.length !== hooks[hookType]?.length) {\n      throw new XDLError(\n        'HOOK_INITIALIZATION_ERROR',\n        `Please fix your ${hookType} hook configuration`\n      );\n    }\n  }\n\n  return validHooks;\n}\n\nexport async function runHook(hook: LoadedHook, hookOptions: Omit<HookArguments, 'config'>) {\n  let result = hook._fn({\n    config: hook.config,\n    ...hookOptions,\n  });\n\n  // If it's a promise, wait for it to resolve\n  if (result && result.then) {\n    result = await result;\n  }\n\n  if (result) {\n    logger.global.info({ quiet: true }, result);\n  }\n}\n"],"file":"runHook.js"}