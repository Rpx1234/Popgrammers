{"version":3,"sources":["../../../../../../src/apple/native-run/ios/lib/protocol/protocol.ts"],"names":["BPLIST_MAGIC","Buffer","from","ProtocolReaderFactory","constructor","ProtocolReader","create","callback","headerSize","alloc","onData","bind","data","buffer","concat","bodyLength","length","parseHeader","slice","parseBody","body","err","PlistProtocolReader","compare","plist","parse","toString","ProtocolClient","socket","readerFactory","writer","sendMessage","msg","Promise","resolve","reject","reader","resp","value","removeListener","on","write"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2021 Expo, Inc.\n * Copyright (c) 2018 Drifty Co.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport plist from '@expo/plist';\nimport type * as net from 'net';\n\nimport { parsePlistBuffer } from '../../../../../utils/parseBinaryPlistAsync';\n\nconst BPLIST_MAGIC = Buffer.from('bplist00');\n\nexport type ProtocolReaderCallback = (resp: any, err?: Error) => void;\n\nexport class ProtocolReaderFactory<T> {\n  constructor(private ProtocolReader: new (callback: ProtocolReaderCallback) => T) {}\n\n  create(callback: (resp: any, err?: Error) => void): T {\n    return new this.ProtocolReader(callback);\n  }\n}\n\nexport abstract class ProtocolReader {\n  protected body!: Buffer; // TODO: ! -> ?\n  protected bodyLength!: number; // TODO: ! -> ?\n  protected buffer = Buffer.alloc(0);\n  constructor(protected headerSize: number, protected callback: ProtocolReaderCallback) {\n    this.onData = this.onData.bind(this);\n  }\n\n  /** Returns length of body, or -1 if header doesn't contain length */\n  protected abstract parseHeader(data: Buffer): number;\n  protected abstract parseBody(data: Buffer): any;\n\n  onData(data?: Buffer) {\n    try {\n      // if there's data, add it on to existing buffer\n      this.buffer = data ? Buffer.concat([this.buffer, data]) : this.buffer;\n      // we haven't gotten the body length from the header yet\n      if (!this.bodyLength) {\n        if (this.buffer.length < this.headerSize) {\n          // partial header, wait for rest\n          return;\n        }\n        this.bodyLength = this.parseHeader(this.buffer);\n        // move on to body\n        this.buffer = this.buffer.slice(this.headerSize);\n        if (!this.buffer.length) {\n          // only got header, wait for body\n          return;\n        }\n      }\n      if (this.buffer.length < this.bodyLength) {\n        // wait for rest of body\n        return;\n      }\n\n      if (this.bodyLength === -1) {\n        this.callback(this.parseBody(this.buffer));\n        this.buffer = Buffer.alloc(0);\n      } else {\n        this.body = this.buffer.slice(0, this.bodyLength);\n        this.bodyLength -= this.body.length;\n        if (!this.bodyLength) {\n          this.callback(this.parseBody(this.body));\n        }\n        this.buffer = this.buffer.slice(this.body.length);\n        // There are multiple messages here, call parse again\n        if (this.buffer.length) {\n          this.onData();\n        }\n      }\n    } catch (err: any) {\n      this.callback(null, err);\n    }\n  }\n}\n\nexport abstract class PlistProtocolReader extends ProtocolReader {\n  protected parseBody(body: Buffer) {\n    if (BPLIST_MAGIC.compare(body, 0, 8) === 0) {\n      return parsePlistBuffer(body);\n    } else {\n      return plist.parse(body.toString('utf8'));\n    }\n  }\n}\n\nexport interface ProtocolWriter {\n  write(sock: net.Socket, msg: any): void;\n}\n\nexport abstract class ProtocolClient<MessageType = any> {\n  constructor(\n    public socket: net.Socket,\n    protected readerFactory: ProtocolReaderFactory<ProtocolReader>,\n    protected writer: ProtocolWriter\n  ) {}\n\n  sendMessage<ResponseType = any>(msg: MessageType): Promise<ResponseType>;\n  sendMessage<CallbackType = void, ResponseType = any>(\n    msg: MessageType,\n    callback: (response: ResponseType, resolve: any, reject: any) => void\n  ): Promise<CallbackType>;\n  sendMessage<CallbackType = void, ResponseType = any>(\n    msg: MessageType,\n    callback?: (response: ResponseType, resolve: any, reject: any) => void\n  ): Promise<CallbackType | ResponseType> {\n    return new Promise<ResponseType | CallbackType>((resolve, reject) => {\n      const reader = this.readerFactory.create(async (resp: ResponseType, err?: Error) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        if (callback) {\n          callback(\n            resp,\n            (value: any) => {\n              this.socket.removeListener('data', reader.onData);\n              resolve(value);\n            },\n            reject\n          );\n        } else {\n          this.socket.removeListener('data', reader.onData);\n          resolve(resp);\n        }\n      });\n      this.socket.on('data', reader.onData);\n      this.writer.write(this.socket, msg);\n    });\n  }\n}\n"],"file":"protocol.js"}