{"version":3,"sources":["../../src/start/ngrok.ts"],"names":["NGROK_CONFIG","authToken","authTokenPublicId","domain","getNgrokConfigPath","path","join","UserSettings","dotExpoHomeDirectory","getProjectRandomnessAsync","projectRoot","ps","ProjectSettings","readAsync","randomness","urlRandomness","resetProjectRandomnessAsync","UrlUtils","someRandomness","setAsync","connectToNgrokAsync","ngrok","args","hostnameAsync","ngrokPid","attempts","configPath","hostname","url","connect","onStatusChange","handleStatusChange","bind","e","message","XDLError","toString","JSON","stringify","error_code","process","kill","ProjectUtils","logDebug","TUNNEL_TIMEOUT","startTunnelsAsync","options","username","UserManager","getCurrentUsernameAsync","ANONYMOUS_USERNAME","packagerInfo","readPackagerInfoAsync","packagerPort","expoServerPort","stopTunnelsAsync","Android","startAdbReverseAsync","logInfo","packageShortName","parse","base","expRc","startedTunnelsSuccessfully","Promise","race","Error","createResolver","extra","resolveHostnameAsync","manifestTunnelRandomness","domainify","isLegacyDevServer","expoServerNgrokUrl","authtoken","port","proto","packagerNgrokUrl","setPackagerInfoAsync","getActiveProcess","pid","logWithLevel","tag","_expoEventType","shouldPrompt","catch","ngrokProcess","ngrokProcessPid","stopAdbReverseAsync","status","logError"],"mappings":"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","sourcesContent":["import { readExpRcAsync } from '@expo/config';\nimport * as path from 'path';\n\nimport {\n  Android,\n  ANONYMOUS_USERNAME,\n  assertValidProjectRoot,\n  delayAsync,\n  NgrokOptions,\n  ProjectSettings,\n  ProjectUtils,\n  resolveNgrokAsync,\n  UserManager,\n  UserSettings,\n  XDLError,\n} from '../internal';\nimport * as UrlUtils from './ngrokUrl';\n\nconst NGROK_CONFIG = {\n  authToken: '5W1bR67GNbWcXqmxZzBG1_56GezNeaX6sSRvn8npeQ8',\n  authTokenPublicId: '5W1bR67GNbWcXqmxZzBG1',\n  domain: 'exp.direct',\n};\n\nfunction getNgrokConfigPath() {\n  return path.join(UserSettings.dotExpoHomeDirectory(), 'ngrok.yml');\n}\n\nasync function getProjectRandomnessAsync(projectRoot: string) {\n  const ps = await ProjectSettings.readAsync(projectRoot);\n  const randomness = ps.urlRandomness;\n  if (randomness) {\n    return randomness;\n  } else {\n    return resetProjectRandomnessAsync(projectRoot);\n  }\n}\n\nasync function resetProjectRandomnessAsync(projectRoot: string) {\n  const randomness = UrlUtils.someRandomness();\n  ProjectSettings.setAsync(projectRoot, { urlRandomness: randomness });\n  return randomness;\n}\n\nasync function connectToNgrokAsync(\n  projectRoot: string,\n  ngrok: any,\n  args: NgrokOptions,\n  hostnameAsync: () => Promise<string>,\n  ngrokPid: number | null | undefined,\n  attempts: number = 0\n): Promise<string> {\n  try {\n    const configPath = getNgrokConfigPath();\n    const hostname = await hostnameAsync();\n    const url = await ngrok.connect({\n      hostname,\n      configPath,\n      onStatusChange: handleStatusChange.bind(null, projectRoot),\n      ...args,\n    });\n    return url;\n  } catch (e: any) {\n    // Attempt to connect 3 times\n    if (attempts >= 2) {\n      if (e.message) {\n        throw new XDLError('NGROK_ERROR', e.toString());\n      } else {\n        throw new XDLError('NGROK_ERROR', JSON.stringify(e));\n      }\n    }\n    if (!attempts) {\n      attempts = 0;\n    } // Attempt to fix the issue\n    if (e.error_code && e.error_code === 103) {\n      if (attempts === 0) {\n        // Failed to start tunnel. Might be because url already bound to another session.\n        if (ngrokPid) {\n          try {\n            process.kill(ngrokPid, 'SIGKILL');\n          } catch (e) {\n            ProjectUtils.logDebug(projectRoot, 'expo', `Couldn't kill ngrok with PID ${ngrokPid}`);\n          }\n        } else {\n          await ngrok.kill();\n        }\n      } else {\n        // Change randomness to avoid conflict if killing ngrok didn't help\n        await resetProjectRandomnessAsync(projectRoot);\n      }\n    } // Wait 100ms and then try again\n    await delayAsync(100);\n    return connectToNgrokAsync(projectRoot, ngrok, args, hostnameAsync, null, attempts + 1);\n  }\n}\n\nconst TUNNEL_TIMEOUT = 10 * 1000;\n\nexport async function startTunnelsAsync(\n  projectRoot: string,\n  options: { autoInstall?: boolean } = {}\n): Promise<void> {\n  const ngrok = await resolveNgrokAsync(projectRoot, options);\n  const username = (await UserManager.getCurrentUsernameAsync()) || ANONYMOUS_USERNAME;\n  assertValidProjectRoot(projectRoot);\n  const packagerInfo = await ProjectSettings.readPackagerInfoAsync(projectRoot);\n  if (!packagerInfo.packagerPort) {\n    throw new XDLError('NO_PACKAGER_PORT', `No packager found for project at ${projectRoot}.`);\n  }\n  if (!packagerInfo.expoServerPort) {\n    throw new XDLError(\n      'NO_EXPO_SERVER_PORT',\n      `No Expo server found for project at ${projectRoot}.`\n    );\n  }\n  const expoServerPort = packagerInfo.expoServerPort;\n  await stopTunnelsAsync(projectRoot);\n  if (await Android.startAdbReverseAsync(projectRoot)) {\n    ProjectUtils.logInfo(\n      projectRoot,\n      'expo',\n      'Successfully ran `adb reverse`. Localhost URLs should work on the connected Android device.'\n    );\n  }\n  const packageShortName = path.parse(projectRoot).base;\n  const expRc = await readExpRcAsync(projectRoot);\n\n  let startedTunnelsSuccessfully = false;\n\n  // Some issues with ngrok cause it to hang indefinitely. After\n  // TUNNEL_TIMEOUTms we just throw an error.\n  await Promise.race([\n    (async () => {\n      await delayAsync(TUNNEL_TIMEOUT);\n      if (!startedTunnelsSuccessfully) {\n        throw new Error('Starting tunnels timed out');\n      }\n    })(),\n\n    (async () => {\n      const createResolver = (extra: string[] = []) =>\n        async function resolveHostnameAsync() {\n          const randomness = expRc.manifestTunnelRandomness\n            ? expRc.manifestTunnelRandomness\n            : await getProjectRandomnessAsync(projectRoot);\n          return [\n            ...extra,\n            randomness,\n            UrlUtils.domainify(username),\n            UrlUtils.domainify(packageShortName),\n            NGROK_CONFIG.domain,\n          ].join('.');\n        };\n\n      // If both ports are defined and they don't match then we can assume the legacy dev server is being used.\n      const isLegacyDevServer =\n        !!expoServerPort &&\n        !!packagerInfo.packagerPort &&\n        expoServerPort !== packagerInfo.packagerPort;\n\n      ProjectUtils.logInfo(projectRoot, 'expo', `Using legacy dev server: ${isLegacyDevServer}`);\n\n      const expoServerNgrokUrl = await connectToNgrokAsync(\n        projectRoot,\n        ngrok,\n        {\n          authtoken: NGROK_CONFIG.authToken,\n          port: expoServerPort,\n          proto: 'http',\n        },\n        createResolver(),\n        packagerInfo.ngrokPid\n      );\n\n      let packagerNgrokUrl: string;\n      if (isLegacyDevServer) {\n        packagerNgrokUrl = await connectToNgrokAsync(\n          projectRoot,\n          ngrok,\n          {\n            authtoken: NGROK_CONFIG.authToken,\n            port: packagerInfo.packagerPort,\n            proto: 'http',\n          },\n          createResolver(['packager']),\n          packagerInfo.ngrokPid\n        );\n      } else {\n        // Custom dev server will share the port across expo and metro dev servers,\n        // this means we only need one ngrok URL.\n        packagerNgrokUrl = expoServerNgrokUrl;\n      }\n\n      await ProjectSettings.setPackagerInfoAsync(projectRoot, {\n        expoServerNgrokUrl,\n        packagerNgrokUrl,\n        ngrokPid: ngrok.getActiveProcess().pid,\n      });\n\n      startedTunnelsSuccessfully = true;\n\n      ProjectUtils.logWithLevel(\n        projectRoot,\n        'info',\n        {\n          tag: 'expo',\n          _expoEventType: 'TUNNEL_READY',\n        },\n        'Tunnel ready.'\n      );\n    })(),\n  ]);\n}\n\nexport async function stopTunnelsAsync(projectRoot: string): Promise<void> {\n  assertValidProjectRoot(projectRoot);\n  const ngrok = await resolveNgrokAsync(projectRoot, { shouldPrompt: false }).catch(() => null);\n  if (!ngrok) {\n    return;\n  }\n\n  // This will kill all ngrok tunnels in the process.\n  // We'll need to change this if we ever support more than one project\n  // open at a time in XDE.\n  const packagerInfo = await ProjectSettings.readPackagerInfoAsync(projectRoot);\n  const ngrokProcess = ngrok.getActiveProcess();\n  const ngrokProcessPid = ngrokProcess ? ngrokProcess.pid : null;\n  if (packagerInfo.ngrokPid && packagerInfo.ngrokPid !== ngrokProcessPid) {\n    // Ngrok is running in some other process. Kill at the os level.\n    try {\n      process.kill(packagerInfo.ngrokPid);\n    } catch (e) {\n      ProjectUtils.logDebug(\n        projectRoot,\n        'expo',\n        `Couldn't kill ngrok with PID ${packagerInfo.ngrokPid}`\n      );\n    }\n  } else {\n    // Ngrok is running from the current process. Kill using ngrok api.\n    await ngrok.kill();\n  }\n  await ProjectSettings.setPackagerInfoAsync(projectRoot, {\n    expoServerNgrokUrl: null,\n    packagerNgrokUrl: null,\n    ngrokPid: null,\n  });\n  await Android.stopAdbReverseAsync(projectRoot);\n}\n\nfunction handleStatusChange(projectRoot: string, status: string) {\n  if (status === 'closed') {\n    ProjectUtils.logError(\n      projectRoot,\n      'expo',\n      'We noticed your tunnel is having issues. ' +\n        'This may be due to intermittent problems with our tunnel provider. ' +\n        'If you have trouble connecting to your app, try to Restart the project, ' +\n        'or switch Host to LAN.'\n    );\n  } else if (status === 'connected') {\n    ProjectUtils.logInfo(projectRoot, 'expo', 'Tunnel connected.');\n  }\n}\n"],"file":"ngrok.js"}