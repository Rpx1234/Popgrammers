{"version":3,"sources":["../../src/utils/formatStackTrace.ts"],"names":["getStringBetweenParens","value","regExp","matches","exec","length","focusLastPathComponent","parts","split","last","pop","current","chalk","dim","join","formatStackTrace","stacktrace","command","treeStackLines","line","first","trim","push","map","index","shift","bold","startsWith","branch","filter","Boolean"],"mappings":"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","sourcesContent":["import chalk from 'chalk';\n\nfunction getStringBetweenParens(value: string): string {\n  const regExp = /\\(([^)]+)\\)/;\n  const matches = regExp.exec(value);\n  if (matches && matches?.length > 1) {\n    return matches[1];\n  }\n  return value;\n}\n\nfunction focusLastPathComponent(value: string): string {\n  const parts = value.split('/');\n  if (parts.length > 1) {\n    const last = parts.pop();\n    const current = chalk.dim(parts.join('/') + '/');\n    return `${current}${last}`;\n  }\n  return chalk.dim(value);\n}\n\nexport function formatStackTrace(stacktrace: string, command: string): string {\n  const treeStackLines: string[][] = [];\n  for (const line of stacktrace.split('\\n')) {\n    const [first, ...parts] = line.trim().split(' ');\n    // Remove at -- we'll use a branch instead.\n    if (first === 'at') {\n      treeStackLines.push(parts);\n    }\n  }\n\n  return treeStackLines\n    .map((parts, index) => {\n      let first = parts.shift();\n      let last = parts.pop();\n\n      // Replace anonymous with command name\n      if (first === 'Command.<anonymous>') {\n        first = chalk.bold(`expo ${command}`);\n      } else if (first?.startsWith('Object.')) {\n        // Remove extra JS types from function names\n        first = first.split('Object.').pop()!;\n      } else if (first?.startsWith('Function.')) {\n        // Remove extra JS types from function names\n        first = first.split('Function.').pop()!;\n      } else if (first?.startsWith('/')) {\n        // If the first element is a path\n        first = focusLastPathComponent(getStringBetweenParens(first));\n      }\n\n      if (last) {\n        last = focusLastPathComponent(getStringBetweenParens(last));\n      }\n      const branch = (index === treeStackLines.length - 1 ? '└' : '├') + '─';\n      return ['   ', branch, first, ...parts, last].filter(Boolean).join(' ');\n    })\n    .join('\\n');\n}\n"],"file":"formatStackTrace.js"}