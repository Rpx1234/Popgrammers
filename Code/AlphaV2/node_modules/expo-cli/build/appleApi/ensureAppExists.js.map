{"version":3,"sources":["../../src/appleApi/ensureAppExists.ts"],"names":["ensureBundleIdExistsAsync","authCtx","accountName","projectName","bundleIdentifier","options","ensureBundleIdExistsWithNameAsync","name","context","spinner","chalk","dim","start","bundleId","BundleId","findAsync","identifier","text","createAsync","succeed","err","message","match","fail","bold","team","id","updateBundleIdCapabilityAsync","capabilityType","CapabilityType","PUSH_NOTIFICATIONS","option","enablePushNotifications","CapabilityTypeOption","ON","OFF"],"mappings":"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","sourcesContent":["import { BundleId, CapabilityType, CapabilityTypeOption } from '@expo/apple-utils';\nimport chalk from 'chalk';\n\nimport { ora } from '../utils/ora';\nimport { AppleCtx, getRequestContext } from './authenticate';\nimport { assertContractMessagesAsync } from './contractMessages';\n\nexport interface EnsureAppExistsOptions {\n  enablePushNotifications?: boolean;\n}\n\nexport interface AppLookupParams {\n  accountName: string;\n  projectName: string;\n  bundleIdentifier: string;\n}\n\nexport async function ensureBundleIdExistsAsync(\n  authCtx: AppleCtx,\n  { accountName, projectName, bundleIdentifier }: AppLookupParams,\n  options?: EnsureAppExistsOptions\n) {\n  return ensureBundleIdExistsWithNameAsync(\n    authCtx,\n    {\n      name: `@${accountName}/${projectName}`,\n      bundleIdentifier,\n    },\n    options\n  );\n}\n\nexport async function ensureBundleIdExistsWithNameAsync(\n  authCtx: AppleCtx,\n  { name, bundleIdentifier }: { name: string; bundleIdentifier: string },\n  options?: EnsureAppExistsOptions\n) {\n  const context = getRequestContext(authCtx);\n  let spinner = ora(`Linking bundle identifier ${chalk.dim(bundleIdentifier)}`).start();\n\n  let bundleId: BundleId | null;\n  try {\n    // Get the bundle id\n    bundleId = await BundleId.findAsync(context, { identifier: bundleIdentifier });\n\n    if (!bundleId) {\n      spinner.text = `Registering bundle identifier ${chalk.dim(bundleIdentifier)}`;\n      // If it doesn't exist, create it\n      bundleId = await BundleId.createAsync(context, {\n        name,\n        identifier: bundleIdentifier,\n      });\n    }\n    spinner.succeed(`Bundle identifier registered ${chalk.dim(bundleIdentifier)}`);\n  } catch (err) {\n    if (err.message.match(/An App ID with Identifier '(.*)' is not available/)) {\n      spinner.fail(\n        `The bundle identifier ${chalk.bold(bundleIdentifier)} is not available to team \"${\n          authCtx.team.name\n        }\" (${authCtx.team.id}), please change it in your app config and try again.`\n      );\n    } else {\n      spinner.fail(`Failed to register bundle identifier ${chalk.dim(bundleIdentifier)}`);\n\n      // Assert contract errors for easier resolution when the user has an expired developer account.\n      if (err.message.match(/forbidden for security reasons/)) {\n        await assertContractMessagesAsync(context);\n      }\n    }\n\n    throw err;\n  }\n\n  if (options) {\n    try {\n      spinner = ora(`Syncing capabilities`).start();\n\n      // Update the capabilities\n      await bundleId.updateBundleIdCapabilityAsync({\n        capabilityType: CapabilityType.PUSH_NOTIFICATIONS,\n        option: options.enablePushNotifications\n          ? CapabilityTypeOption.ON\n          : CapabilityTypeOption.OFF,\n        // TODO: Add more capabilities\n      });\n      spinner.succeed(`Synced capabilities`);\n    } catch (err) {\n      spinner.fail(`Failed to sync capabilities ${chalk.dim(bundleIdentifier)}`);\n\n      throw err;\n    }\n  }\n}\n"],"file":"ensureAppExists.js"}