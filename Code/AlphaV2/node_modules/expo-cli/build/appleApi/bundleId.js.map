{"version":3,"sources":["../../src/appleApi/bundleId.ts"],"names":["getProfilesForBundleIdDangerousAsync","context","bundleIdentifier","bundleId","BundleId","findAsync","identifier","getProfilesAsync","getProfilesForBundleIdAsync","profiles","validProfileIds","Set","Promise","all","map","profile","getBundleIdAsync","add","id","e","name","message","includes","filter","has","getBundleIdForIdentifierAsync","CommandError"],"mappings":";;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA,eAAeA,oCAAf,CACEC,OADF,EAEEC,gBAFF,EAGsB;AACpB,QAAMC,QAAQ,GAAG,MAAMC,uBAASC,SAAT,CAAmBJ,OAAnB,EAA4B;AAAEK,IAAAA,UAAU,EAAEJ;AAAd,GAA5B,CAAvB;;AACA,MAAIC,QAAJ,EAAc;AACZ,WAAOA,QAAQ,CAACI,gBAAT,EAAP;AACD;;AACD,SAAO,EAAP;AACD;;AAEM,eAAeC,2BAAf,CACLP,OADK,EAELC,gBAFK,EAGe;AACpB,QAAMO,QAAQ,GAAG,MAAMT,oCAAoC,CAACC,OAAD,EAAUC,gBAAV,CAA3D,CADoB,CAEpB;AACA;AACA;;AACA,QAAMQ,eAAe,GAAG,IAAIC,GAAJ,EAAxB;AACA,QAAMC,OAAO,CAACC,GAAR,CACJJ,QAAQ,CAACK,GAAT,CAAa,MAAMC,OAAN,IAAiB;AAC5B,QAAI;AACF,YAAMA,OAAO,CAACC,gBAAR,EAAN;AACAN,MAAAA,eAAe,CAACO,GAAhB,CAAoBF,OAAO,CAACG,EAA5B;AACD,KAHD,CAGE,OAAOC,CAAP,EAAU;AACV,UACEA,CAAC,CAACC,IAAF,KAAW,yBAAX,IACAD,CAAC,CAACE,OAAF,CAAUC,QAAV,CAAmB,sEAAnB,CAFF,EAGE;AACA;AACA;AACD;;AACD,YAAMH,CAAN;AACD;AACF,GAdD,CADI,CAAN;AAiBA,SAAOV,QAAQ,CAACc,MAAT,CAAgBR,OAAO,IAAIL,eAAe,CAACc,GAAhB,CAAoBT,OAAO,CAACG,EAA5B,CAA3B,CAAP;AACD;;AAEM,eAAeO,6BAAf,CACLxB,OADK,EAELC,gBAFK,EAGc;AACnB,QAAMC,QAAQ,GAAG,MAAMC,uBAASC,SAAT,CAAmBJ,OAAnB,EAA4B;AAAEK,IAAAA,UAAU,EAAEJ;AAAd,GAA5B,CAAvB;;AACA,MAAI,CAACC,QAAL,EAAe;AACb,UAAM,KAAIuB,uBAAJ,EAAkB,kDAAiDxB,gBAAiB,GAApF,CAAN;AACD;;AACD,SAAOC,QAAP;AACD","sourcesContent":["import { BundleId, Profile, RequestContext } from '@expo/apple-utils';\n\nimport CommandError from '../CommandError';\n\nasync function getProfilesForBundleIdDangerousAsync(\n  context: RequestContext,\n  bundleIdentifier: string\n): Promise<Profile[]> {\n  const bundleId = await BundleId.findAsync(context, { identifier: bundleIdentifier });\n  if (bundleId) {\n    return bundleId.getProfilesAsync();\n  }\n  return [];\n}\n\nexport async function getProfilesForBundleIdAsync(\n  context: RequestContext,\n  bundleIdentifier: string\n): Promise<Profile[]> {\n  const profiles = await getProfilesForBundleIdDangerousAsync(context, bundleIdentifier);\n  // users sometimes have a poisoned Apple cache and receive stale data from the API\n  // we call an arbitrary method, `getBundleIdAsync` on each profile\n  // if it errors, the profile was stale, so we remove it\n  const validProfileIds = new Set();\n  await Promise.all(\n    profiles.map(async profile => {\n      try {\n        await profile.getBundleIdAsync();\n        validProfileIds.add(profile.id);\n      } catch (e) {\n        if (\n          e.name === 'UnexpectedAppleResponse' &&\n          e.message.includes('The specified resource does not exist - There is no resource of type')\n        ) {\n          // TODO: add tracking analytics here\n          return;\n        }\n        throw e;\n      }\n    })\n  );\n  return profiles.filter(profile => validProfileIds.has(profile.id));\n}\n\nexport async function getBundleIdForIdentifierAsync(\n  context: RequestContext,\n  bundleIdentifier: string\n): Promise<BundleId> {\n  const bundleId = await BundleId.findAsync(context, { identifier: bundleIdentifier });\n  if (!bundleId) {\n    throw new CommandError(`Failed to find Bundle ID item with identifier \"${bundleIdentifier}\"`);\n  }\n  return bundleId;\n}\n"],"file":"bundleId.js"}