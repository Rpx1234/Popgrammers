{"version":3,"sources":["../../src/appleApi/provisioningProfileAdhoc.ts"],"names":["uniqueItems","items","set","Set","registerMissingDevicesAsync","context","udids","allIosProfileDevices","Device","getAllIOSProfileDevicesAsync","alreadyAdded","filter","device","includes","attributes","udid","alreadyAddedUdids","map","i","Promise","all","createAsync","name","push","findProfileByBundleIdAsync","bundleId","certSerialNumber","expoProfiles","profile","profileType","ProfileType","IOS_APP_ADHOC","startsWith","profileState","ProfileState","EXPIRED","expoProfilesWithCertificate","certificates","getCertificatesAsync","some","cert","serialNumber","sort","sortByExpiration","length","didUpdate","distributionCertificate","CommandError","regenerateAsync","a","b","Date","expirationDate","getTime","findProfileByIdAsync","profileId","profiles","find","id","manageAdHocProfilesAsync","devices","existingProfile","results","deviceUdidsInProfile","Boolean","allDeviceUdids","hasEqualUdids","every","isValid","result","profileName","provisioningProfileId","provisioningProfile","profileContent","updatedProfile","bundleIdItem","newProfile","Profile","now","didCreate","createOrReuseAdhocProvisioningProfileAsync","authCtx","bundleIdentifier","distCertSerialNumber","spinner","start","adhocProvisioningProfile","succeed","teamId","team","teamName","error","fail","ProvisioningProfileAdhocManager","constructor","ctx","createOrReuse"],"mappings":"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","sourcesContent":["import { Device, Profile, ProfileState, ProfileType, RequestContext } from '@expo/apple-utils';\n\nimport CommandError from '../CommandError';\nimport { ora } from '../utils/ora';\nimport { AppleCtx, getRequestContext } from './authenticate';\nimport { getBundleIdForIdentifierAsync, getProfilesForBundleIdAsync } from './bundleId';\nimport { getDistributionCertificateAync } from './distributionCert';\nimport { ProvisioningProfile } from './provisioningProfile';\n\ninterface ProfileResults {\n  didUpdate?: boolean;\n  didCreate?: boolean;\n  profileName?: string;\n  provisioningProfileId: string;\n  provisioningProfile: any;\n}\n\nfunction uniqueItems<T = any>(items: T[]): T[] {\n  const set = new Set(items);\n  return [...set];\n}\n\nasync function registerMissingDevicesAsync(\n  context: RequestContext,\n  udids: string[]\n): Promise<Device[]> {\n  const allIosProfileDevices = await Device.getAllIOSProfileDevicesAsync(context);\n  const alreadyAdded = allIosProfileDevices.filter(device =>\n    udids.includes(device.attributes.udid)\n  );\n  const alreadyAddedUdids = alreadyAdded.map(i => i.attributes.udid);\n\n  await Promise.all(\n    udids.map(async udid => {\n      if (!alreadyAddedUdids.includes(udid)) {\n        const device = await Device.createAsync(context, {\n          name: 'iOS Device (added by Expo)',\n          udid,\n        });\n        alreadyAdded.push(device);\n      }\n    })\n  );\n\n  return alreadyAdded;\n}\n\nasync function findProfileByBundleIdAsync(\n  context: RequestContext,\n  bundleId: string,\n  certSerialNumber: string\n): Promise<{\n  profile: Profile | null;\n  didUpdate: boolean;\n}> {\n  const expoProfiles = (await getProfilesForBundleIdAsync(context, bundleId)).filter(profile => {\n    return (\n      profile.attributes.profileType === ProfileType.IOS_APP_ADHOC &&\n      profile.attributes.name.startsWith('*[expo]') &&\n      profile.attributes.profileState !== ProfileState.EXPIRED\n    );\n  });\n\n  const expoProfilesWithCertificate: Profile[] = [];\n  // find profiles associated with our development cert\n  for (const profile of expoProfiles) {\n    const certificates = await profile.getCertificatesAsync();\n    if (certificates.some(cert => cert.attributes.serialNumber === certSerialNumber)) {\n      expoProfilesWithCertificate.push(profile);\n    }\n  }\n\n  if (expoProfilesWithCertificate) {\n    // there is an expo managed profile with our desired certificate\n    // return the profile that will be valid for the longest duration\n    return {\n      profile: expoProfilesWithCertificate.sort(sortByExpiration)[\n        expoProfilesWithCertificate.length - 1\n      ],\n      didUpdate: false,\n    };\n  } else if (expoProfiles) {\n    // there is an expo managed profile, but it doesn't have our desired certificate\n    // append the certificate and update the profile\n    const distributionCertificate = await getDistributionCertificateAync(context, certSerialNumber);\n    if (!distributionCertificate) {\n      throw new CommandError(`Certificate for serial number \"${certSerialNumber}\" does not exist`);\n    }\n    const profile = expoProfiles.sort(sortByExpiration)[expoProfiles.length - 1];\n    profile.attributes.certificates = [distributionCertificate];\n    return { profile: await profile.regenerateAsync(), didUpdate: true };\n  }\n\n  // there is no valid provisioning profile available\n  return { profile: null, didUpdate: false };\n}\n\nfunction sortByExpiration(a: Profile, b: Profile): number {\n  return (\n    new Date(a.attributes.expirationDate).getTime() -\n    new Date(b.attributes.expirationDate).getTime()\n  );\n}\n\nasync function findProfileByIdAsync(\n  context: RequestContext,\n  profileId: string,\n  bundleId: string\n): Promise<Profile | null> {\n  let profiles = await getProfilesForBundleIdAsync(context, bundleId);\n  profiles = profiles.filter(\n    profile => profile.attributes.profileType === ProfileType.IOS_APP_ADHOC\n  );\n  return profiles.find(profile => profile.id === profileId) ?? null;\n}\n\nasync function manageAdHocProfilesAsync(\n  context: RequestContext,\n  {\n    udids,\n    bundleId,\n    certSerialNumber,\n    profileId,\n  }: {\n    udids: string[];\n    bundleId: string;\n    certSerialNumber: string;\n    profileId?: string;\n  }\n): Promise<ProfileResults> {\n  // We register all missing devices on the Apple Developer Portal. They are identified by UDIDs.\n  const devices = await registerMissingDevicesAsync(context, udids);\n\n  let existingProfile: Profile | null;\n  let didUpdate = false;\n\n  if (profileId) {\n    existingProfile = await findProfileByIdAsync(context, profileId, bundleId);\n    // Fail if we cannot find the profile that was specifically requested\n    if (!existingProfile)\n      throw new CommandError(\n        `Could not find profile with profile id \"${profileId}\" for bundle id \"${bundleId}\"`\n      );\n  } else {\n    // If no profile id is passed, try to find a suitable provisioning profile for the App ID.\n    const results = await findProfileByBundleIdAsync(context, bundleId, certSerialNumber);\n    existingProfile = results.profile;\n    didUpdate = results.didUpdate;\n  }\n\n  if (existingProfile) {\n    // We need to verify whether the existing profile includes all user's devices.\n    let deviceUdidsInProfile =\n      existingProfile?.attributes?.devices?.map?.(i => i.attributes.udid) ?? [];\n    deviceUdidsInProfile = uniqueItems(deviceUdidsInProfile.filter(Boolean));\n    const allDeviceUdids = uniqueItems(udids);\n    const hasEqualUdids =\n      deviceUdidsInProfile.length === allDeviceUdids.length &&\n      deviceUdidsInProfile.every(udid => allDeviceUdids.includes(udid));\n    if (hasEqualUdids && existingProfile.isValid()) {\n      const result: ProfileResults = {\n        profileName: existingProfile?.attributes?.name,\n        provisioningProfileId: existingProfile?.id,\n        provisioningProfile: existingProfile?.attributes.profileContent,\n      };\n      if (didUpdate) {\n        result.didUpdate = true;\n      }\n\n      return result;\n    }\n    // We need to add new devices to the list and create a new provisioning profile.\n    existingProfile.attributes.devices = devices;\n    await existingProfile.regenerateAsync();\n\n    const updatedProfile = (await findProfileByBundleIdAsync(context, bundleId, certSerialNumber))\n      .profile;\n    if (!updatedProfile) {\n      throw new CommandError(\n        `Failed to locate updated profile for bundle identifier \"${bundleId}\" and serial number \"${certSerialNumber}\"`\n      );\n    }\n    return {\n      didUpdate: true,\n      profileName: updatedProfile.attributes.name,\n      provisioningProfileId: updatedProfile.id,\n      provisioningProfile: updatedProfile.attributes.profileContent,\n    };\n  }\n\n  // No existing profile...\n\n  // We need to find user's distribution certificate to make a provisioning profile for it.\n  const distributionCertificate = await getDistributionCertificateAync(context, certSerialNumber);\n\n  if (!distributionCertificate) {\n    // If the distribution certificate doesn't exist, the user must have deleted it, we can't do anything here :(\n    throw new CommandError(\n      `No distribution certificate for serial number \"${certSerialNumber}\" is available to make a provisioning profile against`\n    );\n  }\n  const bundleIdItem = await getBundleIdForIdentifierAsync(context, bundleId);\n  // If the provisioning profile for the App ID doesn't exist, we just need to create a new one!\n  const newProfile = await Profile.createAsync(context, {\n    bundleId: bundleIdItem.id,\n    // apple drops [ if its the first char (!!),\n    name: `*[expo] ${bundleId} AdHoc ${Date.now()}`,\n    certificates: [distributionCertificate.id],\n    devices: devices.map(device => device.id),\n    profileType: ProfileType.IOS_APP_ADHOC,\n  });\n\n  return {\n    didUpdate: true,\n    didCreate: true,\n    profileName: newProfile.attributes.name,\n    provisioningProfileId: newProfile.id,\n    provisioningProfile: newProfile.attributes.profileContent,\n  };\n}\n\nasync function createOrReuseAdhocProvisioningProfileAsync(\n  authCtx: AppleCtx,\n  udids: string[],\n  bundleIdentifier: string,\n  distCertSerialNumber: string\n): Promise<ProvisioningProfile> {\n  const spinner = ora(`Handling Apple ad hoc provisioning profiles`).start();\n  try {\n    const context = getRequestContext(authCtx);\n    const {\n      didUpdate,\n      didCreate,\n      profileName,\n      ...adhocProvisioningProfile\n    } = await manageAdHocProfilesAsync(context, {\n      udids,\n      bundleId: bundleIdentifier,\n      certSerialNumber: distCertSerialNumber,\n    });\n\n    if (didCreate) {\n      spinner.succeed(`Created new profile: ${profileName}`);\n    } else if (didUpdate) {\n      spinner.succeed(`Updated existing profile: ${profileName}`);\n    } else {\n      spinner.succeed(`Used existing profile: ${profileName}`);\n    }\n\n    return {\n      ...adhocProvisioningProfile,\n      teamId: authCtx.team.id,\n      teamName: authCtx.team.name,\n    };\n  } catch (error) {\n    spinner.fail(`Failed to handle Apple profiles`);\n    throw error;\n  }\n}\n\nexport class ProvisioningProfileAdhocManager {\n  constructor(public ctx: AppleCtx) {}\n\n  async createOrReuse(\n    udids: string[],\n    bundleIdentifier: string,\n    distCertSerialNumber: string\n  ): Promise<ProvisioningProfile> {\n    return createOrReuseAdhocProvisioningProfileAsync(\n      this.ctx,\n      udids,\n      bundleIdentifier,\n      distCertSerialNumber\n    );\n  }\n}\n"],"file":"provisioningProfileAdhoc.js"}