{"version":3,"sources":["../../../src/commands/utils/validateApplicationId.ts"],"names":["validateBundleId","value","test","validatePackage","cachedBundleIdResults","cachedPackageNameResults","getBundleIdWarningAsync","bundleId","url","response","json","resultCount","firstApp","results","message","formatInUseWarning","trackName","sellerName","getPackageNameWarningAsync","packageName","status","chalk","bold","dim","appName","author","id","italic"],"mappings":";;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEO,SAASA,gBAAT,CAA0BC,KAA1B,EAAkD;AACvD,SAAO,mBAAmBC,IAAnB,CAAwBD,KAAxB,CAAP;AACD;;AAEM,SAASE,eAAT,CAAyBF,KAAzB,EAAiD;AACtD,SAAO,oDAAoDC,IAApD,CAAyDD,KAAzD,CAAP;AACD;;AAED,MAAMG,qBAA6C,GAAG,EAAtD;AACA,MAAMC,wBAAgD,GAAG,EAAzD;AAEA;AACA;AACA;AACA;AACA;;AACO,eAAeC,uBAAf,CAAuCC,QAAvC,EAAiF;AACtF;AACA,MAAIH,qBAAqB,CAACG,QAAD,CAAzB,EAAqC;AACnC,WAAOH,qBAAqB,CAACG,QAAD,CAA5B;AACD;;AAED,MAAI,EAAE,MAAM,gCAAoB,kBAApB,CAAR,CAAJ,EAAsD;AACpD;AACA,WAAO,IAAP;AACD;;AAED,QAAMC,GAAG,GAAI,2CAA0CD,QAAS,EAAhE;;AACA,MAAI;AACF,UAAME,QAAQ,GAAG,MAAM,0BAAMD,GAAN,CAAvB;AACA,UAAME,IAAI,GAAG,MAAMD,QAAQ,CAACC,IAAT,EAAnB;;AACA,QAAIA,IAAI,CAACC,WAAL,GAAmB,CAAvB,EAA0B;AACxB,YAAMC,QAAQ,GAAGF,IAAI,CAACG,OAAL,CAAa,CAAb,CAAjB;AACA,YAAMC,OAAO,GAAGC,kBAAkB,CAACH,QAAQ,CAACI,SAAV,EAAqBJ,QAAQ,CAACK,UAA9B,EAA0CV,QAA1C,CAAlC;AACAH,MAAAA,qBAAqB,CAACG,QAAD,CAArB,GAAkCO,OAAlC;AACA,aAAOA,OAAP;AACD;AACF,GATD,CASE,MAAM,CACN;AACD;;AACD,SAAO,IAAP;AACD;;AAEM,eAAeI,0BAAf,CAA0CC,WAA1C,EAAuF;AAC5F;AACA,MAAId,wBAAwB,CAACc,WAAD,CAA5B,EAA2C;AACzC,WAAOd,wBAAwB,CAACc,WAAD,CAA/B;AACD;;AAED,MAAI,EAAE,MAAM,gCAAoB,iBAApB,CAAR,CAAJ,EAAqD;AACnD;AACA,WAAO,IAAP;AACD;;AAED,QAAMX,GAAG,GAAI,iDAAgDW,WAAY,EAAzE;;AACA,MAAI;AACF,UAAMV,QAAQ,GAAG,MAAM,0BAAMD,GAAN,CAAvB,CADE,CAEF;;AACA,QAAIC,QAAQ,CAACW,MAAT,KAAoB,GAAxB,EAA6B;AAC3B;AACA;AACA,YAAMN,OAAO,GAAI,mBAAkBO,iBAAMC,IAAN,CAAWH,WAAX,CAAwB,uBAAsBE,iBAAME,GAAN,CAC/E,+BAAUf,GAAV,CAD+E,CAE/E,EAFF;AAGAH,MAAAA,wBAAwB,CAACc,WAAD,CAAxB,GAAwCL,OAAxC;AACA,aAAOA,OAAP;AACD;AACF,GAZD,CAYE,MAAM,CACN;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASC,kBAAT,CAA4BS,OAA5B,EAA6CC,MAA7C,EAA6DC,EAA7D,EAAiF;AAC/E,SAAQ,eAAcL,iBAAMC,IAAN,CAAWE,OAAX,CAAoB,OAAMH,iBAAMM,MAAN,CAC9CF,MAD8C,CAE9C,qBAAoBJ,iBAAMC,IAAN,CAAWI,EAAX,CAAe,EAFrC;AAGD","sourcesContent":["import chalk from 'chalk';\nimport fetch from 'node-fetch';\n\nimport { learnMore } from './TerminalLink';\nimport { isUrlAvailableAsync } from './url';\n\nexport function validateBundleId(value: string): boolean {\n  return /^[a-zA-Z0-9-.]+$/.test(value);\n}\n\nexport function validatePackage(value: string): boolean {\n  return /^[a-zA-Z][a-zA-Z0-9_]*(\\.[a-zA-Z][a-zA-Z0-9_]*)+$/.test(value);\n}\n\nconst cachedBundleIdResults: Record<string, string> = {};\nconst cachedPackageNameResults: Record<string, string> = {};\n\n/**\n * A quality of life method that provides a warning when the bundle ID is already in use.\n *\n * @param bundleId\n */\nexport async function getBundleIdWarningAsync(bundleId: string): Promise<string | null> {\n  // Prevent fetching for the same ID multiple times.\n  if (cachedBundleIdResults[bundleId]) {\n    return cachedBundleIdResults[bundleId];\n  }\n\n  if (!(await isUrlAvailableAsync('itunes.apple.com'))) {\n    // If no network, simply skip the warnings since they'll just lead to more confusion.\n    return null;\n  }\n\n  const url = `http://itunes.apple.com/lookup?bundleId=${bundleId}`;\n  try {\n    const response = await fetch(url);\n    const json = await response.json();\n    if (json.resultCount > 0) {\n      const firstApp = json.results[0];\n      const message = formatInUseWarning(firstApp.trackName, firstApp.sellerName, bundleId);\n      cachedBundleIdResults[bundleId] = message;\n      return message;\n    }\n  } catch {\n    // Error fetching itunes data.\n  }\n  return null;\n}\n\nexport async function getPackageNameWarningAsync(packageName: string): Promise<string | null> {\n  // Prevent fetching for the same ID multiple times.\n  if (cachedPackageNameResults[packageName]) {\n    return cachedPackageNameResults[packageName];\n  }\n\n  if (!(await isUrlAvailableAsync('play.google.com'))) {\n    // If no network, simply skip the warnings since they'll just lead to more confusion.\n    return null;\n  }\n\n  const url = `https://play.google.com/store/apps/details?id=${packageName}`;\n  try {\n    const response = await fetch(url);\n    // If the page exists, then warn the user.\n    if (response.status === 200) {\n      // There is no JSON API for the Play Store so we can't concisely\n      // locate the app name and developer to match the iOS warning.\n      const message = `⚠️  The package ${chalk.bold(packageName)} is already in use. ${chalk.dim(\n        learnMore(url)\n      )}`;\n      cachedPackageNameResults[packageName] = message;\n      return message;\n    }\n  } catch {\n    // Error fetching play store data or the page doesn't exist.\n  }\n  return null;\n}\n\nfunction formatInUseWarning(appName: string, author: string, id: string): string {\n  return `⚠️  The app ${chalk.bold(appName)} by ${chalk.italic(\n    author\n  )} is already using ${chalk.bold(id)}`;\n}\n"],"file":"validateApplicationId.js"}