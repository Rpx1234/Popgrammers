{"version":3,"sources":["../../../../src/commands/utils/web/getMissingPackages.ts"],"names":["collectMissingPackages","projectRoot","requiredPackages","resolutions","missingPackages","filter","p","resolved","file","pkg","missing","getMissingPackagesAsync","exp","skipSDKVersionRequirement","results","length","mutatePackagesWithKnownVersionsAsync","getSDKVersionsAsync","sdkVersion","sdkVersions","Versions","releasedSdkVersionsAsync","packages","versions","relatedPackages","version"],"mappings":";;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAQO,SAASA,sBAAT,CACLC,WADK,EAELC,gBAFK,EAML;AACA,QAAMC,WAAmC,GAAG,EAA5C;AAEA,QAAMC,eAAe,GAAGF,gBAAgB,CAACG,MAAjB,CAAwBC,CAAC,IAAI;AACnD,QAAI;AACF,YAAMC,QAAQ,GAAG,4BAAYN,WAAZ,EAAyBK,CAAC,CAACE,IAA3B,CAAjB;;AACA,UAAID,QAAJ,EAAc;AACZJ,QAAAA,WAAW,CAACG,CAAC,CAACG,GAAH,CAAX,GAAqBF,QAArB;AACD;;AACD,aAAO,CAACA,QAAR;AACD,KAND,CAME,MAAM;AACN,aAAO,IAAP;AACD;AACF,GAVuB,CAAxB;AAYA,SAAO;AAAEG,IAAAA,OAAO,EAAEN,eAAX;AAA4BD,IAAAA;AAA5B,GAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,eAAeQ,uBAAf,CACLV,WADK,EAEL;AACEW,EAAAA,GAAG,GAAG,yBAAUX,WAAV,EAAuB;AAAEY,IAAAA,yBAAyB,EAAE;AAA7B,GAAvB,EAA4DD,GADpE;AAEEV,EAAAA;AAFF,CAFK,EAYJ;AACD,QAAMY,OAAO,GAAGd,sBAAsB,CAACC,WAAD,EAAcC,gBAAd,CAAtC;;AACA,MAAI,CAACY,OAAO,CAACJ,OAAR,CAAgBK,MAArB,EAA6B;AAC3B,WAAOD,OAAP;AACD,GAJA,CAMD;;;AACA,QAAME,oCAAoC,CAACJ,GAAD,EAAME,OAAO,CAACJ,OAAd,CAA1C;AAEA,SAAOI,OAAP;AACD;;AAED,eAAeG,mBAAf,CAAmCL,GAAnC,EAAyF;AACvF,MAAI;AACF,QAAIA,GAAG,CAACM,UAAR,EAAoB;AAAA;;AAClB,YAAMC,WAAW,GAAG,MAAMC,gBAASC,wBAAT,EAA1B;AACA,sCAAOF,WAAW,CAACP,GAAG,CAACM,UAAL,CAAlB,yEAAsC,IAAtC;AACD;AACF,GALD,CAKE,MAAM,CACN;AACD;;AACD,SAAO,IAAP;AACD;;AAEM,eAAeF,oCAAf,CACLJ,GADK,EAELU,QAFK,EAGL;AACA;AACA,QAAMC,QAAQ,GAAG,MAAMN,mBAAmB,CAACL,GAAD,CAA1C;;AACA,MAAIW,QAAJ,aAAIA,QAAJ,eAAIA,QAAQ,CAAEC,eAAd,EAA+B;AAC7B,SAAK,MAAMf,GAAX,IAAkBa,QAAlB,EAA4B;AAC1B,UAAIb,GAAG,CAACA,GAAJ,IAAWc,QAAQ,CAACC,eAAxB,EAAyC;AACvCf,QAAAA,GAAG,CAACgB,OAAJ,GAAcF,QAAQ,CAACC,eAAT,CAAyBf,GAAG,CAACA,GAA7B,CAAd;AACD;AACF;AACF;;AACD,SAAOa,QAAP;AACD","sourcesContent":["import { getConfig } from '@expo/config';\nimport { ExpoConfig } from '@expo/config-types';\nimport resolveFrom from 'resolve-from';\nimport { Versions } from 'xdl';\n\nexport type ResolvedPackage = {\n  file: string;\n  pkg: string;\n  version?: string;\n};\n\nexport function collectMissingPackages(\n  projectRoot: string,\n  requiredPackages: ResolvedPackage[]\n): {\n  missing: ResolvedPackage[];\n  resolutions: Record<string, string>;\n} {\n  const resolutions: Record<string, string> = {};\n\n  const missingPackages = requiredPackages.filter(p => {\n    try {\n      const resolved = resolveFrom(projectRoot, p.file);\n      if (resolved) {\n        resolutions[p.pkg] = resolved;\n      }\n      return !resolved;\n    } catch {\n      return true;\n    }\n  });\n\n  return { missing: missingPackages, resolutions };\n}\n\n/**\n * Collect missing packages given a list of required packages.\n * Any missing packages will be versioned to the known versions for the current SDK.\n *\n * @param projectRoot\n * @param props.requiredPackages list of required packages to check for\n * @returns list of missing packages and resolutions to existing packages.\n */\nexport async function getMissingPackagesAsync(\n  projectRoot: string,\n  {\n    exp = getConfig(projectRoot, { skipSDKVersionRequirement: true }).exp,\n    requiredPackages,\n  }: {\n    exp?: ExpoConfig;\n    requiredPackages: ResolvedPackage[];\n  }\n): Promise<{\n  missing: ResolvedPackage[];\n  resolutions: Record<string, string>;\n}> {\n  const results = collectMissingPackages(projectRoot, requiredPackages);\n  if (!results.missing.length) {\n    return results;\n  }\n\n  // Ensure the versions are right for the SDK that the project is currently using.\n  await mutatePackagesWithKnownVersionsAsync(exp, results.missing);\n\n  return results;\n}\n\nasync function getSDKVersionsAsync(exp: ExpoConfig): Promise<Versions.SDKVersion | null> {\n  try {\n    if (exp.sdkVersion) {\n      const sdkVersions = await Versions.releasedSdkVersionsAsync();\n      return sdkVersions[exp.sdkVersion] ?? null;\n    }\n  } catch {\n    // This is a convenience method and we should avoid making this halt the process.\n  }\n  return null;\n}\n\nexport async function mutatePackagesWithKnownVersionsAsync(\n  exp: ExpoConfig,\n  packages: ResolvedPackage[]\n) {\n  // Ensure the versions are right for the SDK that the project is currently using.\n  const versions = await getSDKVersionsAsync(exp);\n  if (versions?.relatedPackages) {\n    for (const pkg of packages) {\n      if (pkg.pkg in versions.relatedPackages) {\n        pkg.version = versions.relatedPackages[pkg.pkg];\n      }\n    }\n  }\n  return packages;\n}\n"],"file":"getMissingPackages.js"}