{"version":3,"sources":["../../../../src/commands/utils/fetch-cache/fetch.ts"],"names":["CACHE_VERSION","lockPromiseForKey","unlockFunctionForKey","lock","key","Promise","resolve","takeLockPromise","then","fulfill","unlock","md5","str","crypto","createHash","update","digest","getFormDataCacheKey","formData","cacheKey","boundary","getBoundary","_boundary","boundaryReplaceRegex","RegExp","_streams","map","s","replace","getBodyCacheKeyJson","body","URLSearchParams","toString","fs","ReadStream","path","Buffer","Error","getRequestCacheKey","req","cache","credentials","destination","headers","integrity","method","redirect","referrer","referrerPolicy","url","getCacheKey","requestArguments","resource","init","resourceCacheKeyJson","Request","initCacheKeyJson","agent","JSON","stringify","getResponse","cachedValue","get","ejectSelfFromCache","remove","NFCResponse","bodyStream","metaData","fetchResponse","serializedMeta","serializeMetaFromNodeFetchResponse","newlyCachedData","set","createFetchWithCache"],"mappings":";;;;;;;AAUA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA,MAAMA,aAAa,GAAG,CAAtB;AAEA,MAAMC,iBAA+C,GAAG,EAAxD;AACA,MAAMC,oBAAyC,GAAG,EAAlD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAeC,IAAf,CAAoBC,GAApB,EAAiC;AAC/B,MAAI,CAACH,iBAAiB,CAACG,GAAD,CAAtB,EAA6B;AAC3BH,IAAAA,iBAAiB,CAACG,GAAD,CAAjB,GAAyBC,OAAO,CAACC,OAAR,EAAzB;AACD;;AAED,QAAMC,eAAe,GAAGN,iBAAiB,CAACG,GAAD,CAAzC;AACAH,EAAAA,iBAAiB,CAACG,GAAD,CAAjB,GAAyBG,eAAe,CAACC,IAAhB,CACvB,MACE,IAAIH,OAAJ,CAAYI,OAAO,IAAI;AACrBP,IAAAA,oBAAoB,CAACE,GAAD,CAApB,GAA4BK,OAA5B;AACD,GAFD,CAFqB,CAAzB;AAOA,SAAOF,eAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,MAAT,CAAgBN,GAAhB,EAA6B;AAC3B,MAAIF,oBAAoB,CAACE,GAAD,CAAxB,EAA+B;AAC7BF,IAAAA,oBAAoB,CAACE,GAAD,CAApB;AACA,WAAOF,oBAAoB,CAACE,GAAD,CAA3B;AACD;AACF;;AAED,SAASO,GAAT,CAAaC,GAAb,EAA0B;AACxB,SAAOC,kBAAOC,UAAP,CAAkB,KAAlB,EAAyBC,MAAzB,CAAgCH,GAAhC,EAAqCI,MAArC,CAA4C,KAA5C,CAAP;AACD,C,CAED;AACA;AACA;;;AACA,SAASC,mBAAT,CAA6BC,QAA7B,EAAiD;AAC/C,QAAMC,QAAQ,GAAG,EAAE,GAAGD;AAAL,GAAjB;AACA,QAAME,QAAQ,GAAGF,QAAQ,CAACG,WAAT,EAAjB,CAF+C,CAI/C;;AACA,SAAOF,QAAQ,CAACG,SAAhB;AAEA,QAAMC,oBAAoB,GAAG,IAAIC,MAAJ,CAAWJ,QAAX,EAAqB,GAArB,CAA7B,CAP+C,CAS/C;;AACAD,EAAAA,QAAQ,CAACM,QAAT,GAAoBN,QAAQ,CAACM,QAAT,CAAkBC,GAAlB,CAAsBC,CAAC,IAAI;AAC7C,QAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B;AACzB,aAAOA,CAAC,CAACC,OAAF,CAAUL,oBAAV,EAAgC,EAAhC,CAAP;AACD;;AAED,WAAOI,CAAP;AACD,GANmB,CAApB;AAQA,SAAOR,QAAP;AACD;;AAED,SAASU,mBAAT,CAA6BC,IAA7B,EAAwC;AACtC,MAAI,CAACA,IAAL,EAAW;AACT,WAAOA,IAAP;AACD;;AACD,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,WAAOA,IAAP;AACD;;AACD,MAAIA,IAAI,YAAYC,sBAApB,EAAqC;AACnC,WAAOD,IAAI,CAACE,QAAL,EAAP;AACD;;AACD,MAAIF,IAAI,YAAYG,cAAGC,UAAvB,EAAmC;AACjC,WAAOJ,IAAI,CAACK,IAAZ;AACD;;AACD,MAAIL,IAAI,CAACE,QAAL,IAAiBF,IAAI,CAACE,QAAL,OAAoB,mBAAzC,EAA8D;AAC5D,WAAOf,mBAAmB,CAACa,IAAD,CAA1B;AACD;;AACD,MAAIA,IAAI,YAAYM,MAApB,EAA4B;AAC1B,WAAON,IAAI,CAACE,QAAL,EAAP;AACD;;AAED,QAAM,IAAIK,KAAJ,CACJ,gIADI,CAAN;AAGD;;AAED,SAASC,kBAAT,CAA4BC,GAA5B,EAAsC;AACpC,SAAO;AACLC,IAAAA,KAAK,EAAED,GAAG,CAACC,KADN;AAELC,IAAAA,WAAW,EAAEF,GAAG,CAACE,WAFZ;AAGLC,IAAAA,WAAW,EAAEH,GAAG,CAACG,WAHZ;AAILC,IAAAA,OAAO,EAAEJ,GAAG,CAACI,OAJR;AAKLC,IAAAA,SAAS,EAAEL,GAAG,CAACK,SALV;AAMLC,IAAAA,MAAM,EAAEN,GAAG,CAACM,MANP;AAOLC,IAAAA,QAAQ,EAAEP,GAAG,CAACO,QAPT;AAQLC,IAAAA,QAAQ,EAAER,GAAG,CAACQ,QART;AASLC,IAAAA,cAAc,EAAET,GAAG,CAACS,cATf;AAULC,IAAAA,GAAG,EAAEV,GAAG,CAACU,GAVJ;AAWLnB,IAAAA,IAAI,EAAED,mBAAmB,CAACU,GAAG,CAACT,IAAL;AAXpB,GAAP;AAaD;;AAED,SAASoB,WAAT,CAAqBC,gBAArB,EAA8C;AAC5C,QAAMC,QAAQ,GAAGD,gBAAgB,CAAC,CAAD,CAAjC;AACA,QAAME,IAAI,GAAGF,gBAAgB,CAAC,CAAD,CAAhB,IAAuB,EAApC;AAEA,QAAMG,oBAAoB,GACxBF,QAAQ,YAAYG,oBAApB,GAA8BjB,kBAAkB,CAACc,QAAD,CAAhD,GAA6D;AAAEH,IAAAA,GAAG,EAAEG;AAAP,GAD/D;AAGA,QAAMI,gBAAgB,GAAG,EAAE,GAAGH;AAAL,GAAzB,CAP4C,CAS5C;;AACAC,EAAAA,oBAAoB,CAACxB,IAArB,GAA4BD,mBAAmB,CAACyB,oBAAoB,CAACxB,IAAtB,CAA/C;AACA0B,EAAAA,gBAAgB,CAAC1B,IAAjB,GAAwBD,mBAAmB,CAAC2B,gBAAgB,CAAC1B,IAAlB,CAA3C;AAEA,SAAO0B,gBAAgB,CAACC,KAAxB;AAEA,SAAO9C,GAAG,CAAC+C,IAAI,CAACC,SAAL,CAAe,CAACL,oBAAD,EAAuBE,gBAAvB,EAAyCxD,aAAzC,CAAf,CAAD,CAAV;AACD;;AAED,eAAe4D,WAAf,CACEpB,KADF,EAEES,GAFF,EAGEI,IAHF,EAIE;AACA,QAAMlC,QAAQ,GAAG+B,WAAW,CAAC,CAACD,GAAD,EAAMI,IAAN,CAAD,CAA5B;AACA,MAAIQ,WAAW,GAAG,MAAMrB,KAAK,CAACsB,GAAN,CAAU3C,QAAV,CAAxB;;AAEA,QAAM4C,kBAAkB,GAAG,MAAMvB,KAAK,CAACwB,MAAN,CAAa7C,QAAb,CAAjC;;AAEA,MAAI0C,WAAJ,EAAiB;AACf,WAAO,KAAII,uBAAJ,EAAgBJ,WAAW,CAACK,UAA5B,EAAwCL,WAAW,CAACM,QAApD,EAA8DJ,kBAA9D,EAAkF,IAAlF,CAAP;AACD;;AAED,QAAM5D,IAAI,CAACgB,QAAD,CAAV;;AACA,MAAI;AACF0C,IAAAA,WAAW,GAAG,MAAMrB,KAAK,CAACsB,GAAN,CAAU3C,QAAV,CAApB;;AACA,QAAI0C,WAAJ,EAAiB;AACf,aAAO,KAAII,uBAAJ,EACLJ,WAAW,CAACK,UADP,EAELL,WAAW,CAACM,QAFP,EAGLJ,kBAHK,EAIL,IAJK,CAAP;AAMD;;AAED,UAAMK,aAAa,GAAG,MAAM,0BAAMnB,GAAN,EAAWI,IAAX,CAA5B;;AACA,UAAMgB,cAAc,GAAGJ,wBAAYK,kCAAZ,CAA+CF,aAA/C,CAAvB;;AAEA,UAAMG,eAAe,GAAG,MAAM/B,KAAK,CAACgC,GAAN,CAC5BrD,QAD4B,EAE5B;AACAiD,IAAAA,aAAa,CAACtC,IAHc,EAI5BuC,cAJ4B,CAA9B;AAOA,WAAO,KAAIJ,uBAAJ,EACLM,eAAe,CAAEL,UADZ,EAELK,eAAe,CAAEJ,QAFZ,EAGLJ,kBAHK,EAIL,KAJK,CAAP;AAMD,GA3BD,SA2BU;AACRrD,IAAAA,MAAM,CAACS,QAAD,CAAN;AACD;AACF;;AAED,SAASsD,oBAAT,CACEjC,KADF,EAE2E;AACzE,SAAO,CAACS,GAAD,EAAmBI,IAAnB,KAAsDO,WAAW,CAACpB,KAAD,EAAQS,GAAR,EAAaI,IAAb,CAAxE;AACD;;eAEcoB,oB","sourcesContent":["/**\n * Copyright (c) 2021 Expo, Inc.\n * Copyright (c) 2020 mistval.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Based on https://github.com/mistval/node-fetch-cache/blob/9c40ddf786b0de22ce521d8bdaa6347bc44dd629/src/index.js#L1\n * But with TypeScript support to fix Jest tests, and removed unused code.\n */\nimport crypto from 'crypto';\nimport FormData from 'form-data';\nimport fs from 'fs';\nimport fetch, { Request, RequestInfo, RequestInit, Response } from 'node-fetch';\nimport { URLSearchParams } from 'url';\n\nimport { NFCResponse } from './response';\n\nconst CACHE_VERSION = 3;\n\nconst lockPromiseForKey: Record<string, Promise<any>> = {};\nconst unlockFunctionForKey: Record<string, any> = {};\n\n/**\n * Take out a lock. When this function returns (asynchronously),\n * you have the lock.\n * @param {string} key - The key to lock on. Anyone else who\n *   tries to lock on the same key will need to wait for it to\n *   be unlocked.\n */\nasync function lock(key: string) {\n  if (!lockPromiseForKey[key]) {\n    lockPromiseForKey[key] = Promise.resolve();\n  }\n\n  const takeLockPromise = lockPromiseForKey[key];\n  lockPromiseForKey[key] = takeLockPromise.then(\n    () =>\n      new Promise(fulfill => {\n        unlockFunctionForKey[key] = fulfill;\n      })\n  );\n\n  return takeLockPromise;\n}\n\n/**\n * Release a lock.\n * @param {string} key - The key to release the lock for.\n *   The next person in line will now be able to take out\n *   the lock for that key.\n */\nfunction unlock(key: string) {\n  if (unlockFunctionForKey[key]) {\n    unlockFunctionForKey[key]();\n    delete unlockFunctionForKey[key];\n  }\n}\n\nfunction md5(str: string) {\n  return crypto.createHash('md5').update(str).digest('hex');\n}\n\n// Since the boundary in FormData is random,\n// we ignore it for purposes of calculating\n// the cache key.\nfunction getFormDataCacheKey(formData: FormData) {\n  const cacheKey = { ...formData };\n  const boundary = formData.getBoundary();\n\n  // @ts-expect-error\n  delete cacheKey._boundary;\n\n  const boundaryReplaceRegex = new RegExp(boundary, 'g');\n\n  // @ts-expect-error\n  cacheKey._streams = cacheKey._streams.map(s => {\n    if (typeof s === 'string') {\n      return s.replace(boundaryReplaceRegex, '');\n    }\n\n    return s;\n  });\n\n  return cacheKey;\n}\n\nfunction getBodyCacheKeyJson(body: any) {\n  if (!body) {\n    return body;\n  }\n  if (typeof body === 'string') {\n    return body;\n  }\n  if (body instanceof URLSearchParams) {\n    return body.toString();\n  }\n  if (body instanceof fs.ReadStream) {\n    return body.path;\n  }\n  if (body.toString && body.toString() === '[object FormData]') {\n    return getFormDataCacheKey(body);\n  }\n  if (body instanceof Buffer) {\n    return body.toString();\n  }\n\n  throw new Error(\n    'Unsupported body type. Supported body types are: string, number, undefined, null, url.URLSearchParams, fs.ReadStream, FormData'\n  );\n}\n\nfunction getRequestCacheKey(req: any) {\n  return {\n    cache: req.cache,\n    credentials: req.credentials,\n    destination: req.destination,\n    headers: req.headers,\n    integrity: req.integrity,\n    method: req.method,\n    redirect: req.redirect,\n    referrer: req.referrer,\n    referrerPolicy: req.referrerPolicy,\n    url: req.url,\n    body: getBodyCacheKeyJson(req.body),\n  };\n}\n\nfunction getCacheKey(requestArguments: any[]) {\n  const resource = requestArguments[0];\n  const init = requestArguments[1] || {};\n\n  const resourceCacheKeyJson =\n    resource instanceof Request ? getRequestCacheKey(resource) : { url: resource };\n\n  const initCacheKeyJson = { ...init };\n\n  // @ts-ignore\n  resourceCacheKeyJson.body = getBodyCacheKeyJson(resourceCacheKeyJson.body);\n  initCacheKeyJson.body = getBodyCacheKeyJson(initCacheKeyJson.body);\n\n  delete initCacheKeyJson.agent;\n\n  return md5(JSON.stringify([resourceCacheKeyJson, initCacheKeyJson, CACHE_VERSION]));\n}\n\nasync function getResponse(\n  cache: import('./FileSystemCache').FileSystemCache,\n  url: RequestInfo,\n  init?: RequestInit | undefined\n) {\n  const cacheKey = getCacheKey([url, init]);\n  let cachedValue = await cache.get(cacheKey);\n\n  const ejectSelfFromCache = () => cache.remove(cacheKey);\n\n  if (cachedValue) {\n    return new NFCResponse(cachedValue.bodyStream, cachedValue.metaData, ejectSelfFromCache, true);\n  }\n\n  await lock(cacheKey);\n  try {\n    cachedValue = await cache.get(cacheKey);\n    if (cachedValue) {\n      return new NFCResponse(\n        cachedValue.bodyStream,\n        cachedValue.metaData,\n        ejectSelfFromCache,\n        true\n      );\n    }\n\n    const fetchResponse = await fetch(url, init);\n    const serializedMeta = NFCResponse.serializeMetaFromNodeFetchResponse(fetchResponse);\n\n    const newlyCachedData = await cache.set(\n      cacheKey,\n      // @ts-expect-error\n      fetchResponse.body,\n      serializedMeta\n    );\n\n    return new NFCResponse(\n      newlyCachedData!.bodyStream,\n      newlyCachedData!.metaData,\n      ejectSelfFromCache,\n      false\n    );\n  } finally {\n    unlock(cacheKey);\n  }\n}\n\nfunction createFetchWithCache(\n  cache: import('./FileSystemCache').FileSystemCache\n): (url: RequestInfo, init?: RequestInit | undefined) => Promise<Response> {\n  return (url: RequestInfo, init?: RequestInit | undefined) => getResponse(cache, url, init);\n}\n\nexport default createFetchWithCache;\n"],"file":"fetch.js"}